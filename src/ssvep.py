# -*- coding: utf-8 -*-
"""ssvep.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17WeMnT6HfqfJ7VG3sx6i_qm2HW9S3AFH
"""

# Necessary channels: P7/3/z/4/8, PO-9/10, and O-1/z/2Ð± 23:32
# channels = ['P7', 'P3', 'Pz', 'P4', 'P8', 'PO9', 'O1', 'Oz', 'O2', 'PO10']

# raw_data
# we have n = 100 trials for each subject in one session
# time intervals is time_interval = 0 to 4000 ms
# sampling frequences is fs = 1000 Hz
# we have 4000 data points, since we sample 0-4000 ms interval with 1000 Hz, i.e. each 1 ms
# therefore, smt has dimensions 4000x100x62, 4000 data points x 100 trials x 62 electrodes

# preprocessing for ssvep analysis
# sampling frequence is fs = 100 HZ
# once more we sample raw 4000 data points with 100 Hz, i.e. each 10 ms
# thus, we have 400 data points
# filtered smt for ssvep would have 400x100x10 dimensions

# we have reference signals Yi for each fi
# marker = {'1','up';'2', 'left';'3', 'right';'4', 'down'};
# nClasses = 4;
# freq = 60./[5, 7, 9, 11];
# fs = 100;
# time = 4;

# t= 0:1/fs:time;
# Y = cell(1,nClasses); # list of 4 lists
# r = cell(1,nClasses); # list of 4 lists


# for each trial_data, 400x10 dimension
#   do cca_analysis {
#       for each class (4 classes):
#           r = canoncorr(trial_data, Yi)  it should be 1xd vector
#           r = max(r)
#   }
#

from sklearn.cross_decomposition import CCA
import numpy as np

def get_max_cca_corr(X, Y):
    cca = CCA(n_components=1)
    cca.fit(X, Y)
    X_c, Y_c = cca.transform(X, Y)
    corr = np.corrcoef(X_c.T, Y_c.T).diagonal(offset=1).max()
    return corr

def get_cca_corrs(X, Y_ref):
    r = []
    for i in range(len(Y_ref)):
        r.append(get_max_cca_corr(X, Y_ref[i]))
    return r

def generate_ref_signals(num_classes, freqs, fs, end_time):
    t = np.linspace(0, end_time-1/fs, fs*end_time)
    ref_signals = []
    for i in range(num_classes):
        ref = 2*np.pi*freqs[i]*t
        ref_signals.append(np.array([np.sin(ref), np.cos(ref), np.sin(2*ref), np.cos(2*ref)]).T)
    return ref_signals

def ssvep_preprocess(data_x, data_t, start, end, fs, channels):
    # segmented data shape:  trials x data_points x channels
    segmented_data = np.zeros((len(data_t), end-start, len(channels)))
    for i in range(len(data_t)):
        segmented_data[i] = data_x[(data_t[i]+start):(data_t[i]+end), channels]
    period = int(1000/fs)
    downsampled_data = segmented_data[:,::period,:]
    return downsampled_data

def get_ssvep_features(data, t, num_classes=4, freqs=60/np.array([5,7,9,11]), fs=100, end_time=4):
    """
    default parameters:
    num_classes=4, freqs=60/np.array([5,7,9,11]), fs=100, end_time=4

    input: data
    output: canonical correlation p values between data and ref signals at individual freqs
    """
    channels = [22, 23, 24, 25, 26, 27, 28, 29, 30, 31]
    data = ssvep_preprocess(data_x=data, data_t=t, start=0, end=4000, fs=100, channels=channels)
    Y_refs = generate_ref_signals(num_classes, freqs, fs, end_time)

    p = []
    trials = data.shape[0]
    for i in range(trials):
        p.append(get_cca_corrs(data[i], Y_refs))
    return np.array(p)